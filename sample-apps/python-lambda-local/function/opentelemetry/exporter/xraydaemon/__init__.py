import logging
import opentelemetry.trace as trace_api
import json
from opentelemetry.sdk.trace.export import Span, SpanExporter, SpanExportResult
from opentelemetry.trace import SpanKind
from .emitter import UDPEmitter
import time
import binascii
import os
import random
import datetime

logger = logging.getLogger(__name__)

class TraceId:
    """
    A trace ID tracks the path of a request through your application.
    A trace collects all the segments generated by a single request.
    A trace ID is required for a segment.
    """
    VERSION = '1'
    DELIMITER = '-'

    def __init__(self):
        """
        Generate a random trace id.
        """
        self.start_time = int(time.time())
        self._number = binascii.b2a_hex(os.urandom(12)).decode('utf-8')

    def to_id(self):
        """
        Convert TraceId object to a string.
        """
        return "%s%s%s%s%s" % (TraceId.VERSION, TraceId.DELIMITER,
                               format(self.start_time, 'x'),
                               TraceId.DELIMITER, self._number)

class XrayDaemonSpanExporter(SpanExporter):
    TRACE_ID_VERSION = "1"
    TRACE_ID_DELIMITER = "-"
    TRACE_ID_FIRST_PART_LENGTH = 8

    def __init__(self):
        self._emitter = UDPEmitter()


    def export(self, spans) -> SpanExportResult:
        logger.info('-----------------XrayDaemonSpanExporter emit ----------')
        for span in spans:
            segment = self._translate_to_segment(span)
            entity = json.dumps(segment)
            logger.info(entity)
            self._emitter.send_entity(entity)

        return SpanExportResult.SUCCESS 

    def shutdown(self) -> None:
        pass

    def _translate_to_segment(self, span):
        logger.info(span)
        logger.info(span.context)
        logger.info(span.attributes)
        logger.info(span.resource)
        logger.info(span.parent)

        segment = {}
        segment['name'] = span.name
        # need change to aws trace id format
        traceId = TraceId()
        segment['trace_id'] = traceId.to_id()
        segment['id'] = self._generate_random_id()

        otel_trace_id = "{:032x}".format(span.context.trace_id)
        xray_trace_id = (
            self.TRACE_ID_VERSION +
            self.TRACE_ID_DELIMITER +
            otel_trace_id[:self.TRACE_ID_FIRST_PART_LENGTH] +
            self.TRACE_ID_DELIMITER +
            otel_trace_id[self.TRACE_ID_FIRST_PART_LENGTH:]
        )
        id = "{:016x}".format(span.context.span_id)
        segment['trace_id'] = xray_trace_id
        segment['id'] = id

        parent_context = span.parent
        if parent_context:
            parent_id = "{:016x}".format(parent_context.span_id)
            segment['parent_id'] = parent_id

        # no idea what is the best practice Python process time
        segment['start_time'] = span._start_time/1000000000
        segment['end_time'] = span._end_time/1000000000

        # should check kind == server
        if span.kind == SpanKind.SERVER:
            segment['type'] = 'segment'
            segment['origin'] = 'AWS::Lambda'
        else:
            # TODO: segment['type'] = 'subsegment'
            segment['type'] = 'subsegment'
            # TODO: aws or remote, check attribute `myServiceNS`
            segment['namespace'] = 'aws'

        # xray resources
        segment['aws'] = span.resource._attributes

        # throw everything into metadata
        awsDict = {**(span.attributes._dict), **(span.resource._attributes)}
        segment['metadata'] = awsDict

        return segment

    def _generate_random_id(self):
        """
        Generate a random 16-digit hex str.
        This is used for generating segment/subsegment id.
        """
        return binascii.b2a_hex(os.urandom(8)).decode('utf-8')

    def generate_span_id(self) -> int:
        return random.getrandbits(64)

    def generate_trace_id(self) -> int:
        # return random.getrandbits(128)
        trace_time = int(datetime.datetime.utcnow().timestamp())
        trace_identifier = random.getrandbits(96)
        return (trace_time << 96) + trace_identifier